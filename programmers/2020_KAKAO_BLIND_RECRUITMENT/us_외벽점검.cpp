#include <string>
#include <vector>
#include <iostream>

using namespace std;

/*
느낌 상 그리디인데 원형 테두리 상에서 진행되는 그리디 느낌
원형 테두리 구현할 때 % 활용하는 것보다 직관적으로 하는 법이 생각났는데, 
어차피 친구 한명이 갈 수 있는 최대 거리는 100이므로 199에서 출발한다고 해도 299까지밖에 못가고
0에서 출발해도 -100까지밖에 못감.
이걸 이용해서 -100 ~ 299 즉 길이 400짜리 배열 하나를 만들고 (n이 200이라 할떄) -1번과 199번을 같은 포인터로 설정해두면 비교적 쉽게 그리디 구현이 가능하지 않을까 싶음.

이번엔 실제로 최소명수를 구할 방법을 고민해보자.
무조건 이동거리가 긴 친구부터 사용하는 게 이득이므로
앞서 말한 방법대로 원형 테두리를 하나의 어레이로 표현한 이후
인덱스 0부터 끝까지 돌면서 길이 d인 막대가 최대한 많은 취약지점을 덮는 경우가 언제인지를 구한다.
그후 덮인 지점 및 그 덮인 지점과 같은 포인터를 공유하는 지점들을 제거해주고
같은 과정을 반복하면 답이 나올 듯 하다.

친구 8명에 for loop, 커봐야 O(400)이니까 충분히 가능.
*/

bool weakWalls[201] = {0,};
int walls[401]; // walls[i] = 101이 0번일 때 i=101+d만큼 이동했을 때의 외벽 위치

int solution(int n, vector<int> weak, vector<int> dist) 
{
    int answer = 0;
    
    // 초기화
    // 무조건 101번이 weakWalls 0번, 그리고 100+n번이 weakWalls n번과 맵핑된다.
    // 그 후 101+n은 다시 0, 100+2n은 n과 맵핑, 이를 401 도착할 때까지 반복한다.
    for (const int& i : weak) weakWalls[i] = true;
    
    for (int i=0;i<n;++i)
    {
        walls[101+i] = i;
    }
    // TODO
    
    // 풀이
    // TODO
    
    return answer;
}
